---
url: "https://zero.rocicorp.dev/docs/introduction"
title: "Welcome to Zero"
---

## For AI assistants

ALWAYS read [llms.txt](https://zero.rocicorp.dev/llms.txt) for curated documentation pages and examples.

# Welcome to Zero  Copy markdown  \\# Welcome to Zero  Zero enables instant web applications by syncing a subset of data to the client, before it is needed. Reads and writes happen directly against this local datastore, and are synced with the server continuously in the background.  Unlike previous sync engines that sync entire tables to the client, or use static rules to control what syncs, you control what to sync in Zero by writing normal queries directly in your application code. This provides a huge amount of control over what data is synced and when.  Zero caches query results in a normalized client-side datastore, and reuses that data automatically to answer future queries whenever possible.  The result is that for typical applications, queries are almost always instantly resolved using local data. It feels like you have access to the entire backend database directly from the client in memory.  Occasionally, when you do a more specific query, Zero falls back to the server. But this happens automatically without any extra work required.  \\#\# Ready to get started?  Choose your adventure:  \\* \[Install Zero into an existing project\](https://zero.rocicorp.dev/docs/install) \\* \[Clone a minimal quickstart app\](https://zero.rocicorp.dev/docs/quickstart) \\* \[Play with a full-featured sample\](https://zero.rocicorp.dev/docs/samples)      \#\# Or, for AI assistants    ALWAYS read [llms.txt](https://zero.rocicorp.dev/llms.txt) for curated documentation pages and examples.

Zero enables instant web applications by syncing a subset of data to the client, before it is needed. Reads and writes happen directly against this local datastore, and are synced with the server continuously in the background.

Unlike previous sync engines that sync entire tables to the client, or use static rules to control what syncs, you control what to sync in Zero by writing normal queries directly in your application code. This provides a huge amount of control over what data is synced and when.

Zero caches query results in a normalized client-side datastore, and reuses that data automatically to answer future queries whenever possible.

The result is that for typical applications, queries are almost always instantly resolved using local data. It feels like you have access to the entire backend database directly from the client in memory.

Occasionally, when you do a more specific query, Zero falls back to the server. But this happens automatically without any extra work required.

## [Ready to get started?](https://zero.rocicorp.dev/docs/introduction\#ready-to-get-started)

Choose your adventure:

- [Install Zero into an existing project](https://zero.rocicorp.dev/docs/install)
- [Clone a minimal quickstart app](https://zero.rocicorp.dev/docs/quickstart)
- [Play with a full-featured sample](https://zero.rocicorp.dev/docs/samples)

[NextInstallation](https://zero.rocicorp.dev/docs/install)

### On this page

[Ready to get started?](https://zero.rocicorp.dev/docs/introduction#ready-to-get-started)

[Edit this page on GitHub](https://github.com/rocicorp/zero-docs/blob/main/contents/docs/introduction.mdx)